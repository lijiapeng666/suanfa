<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>




    <!-- <script>
        // let str = "good good study, day day up!";
        // // => 学正则就是用来制定规则(是否包含连续的数字)
        // let reg = /\d+/; // \d代表0～9之间数字，+代表多次
        // reg.test(str) // =>false

        // str = "2019-08-12"
        // reg.exec(str) //=>["2019",index:0,inputs:"原始字符串"]
        // -------------------------------
        // let reg = /^\d/      //以数字开头 
        // let reg = /\d$/     //以数字结尾
        // let reg = /\d/     //包含数字就可以
        // let reg = /^\d+$/
        // let reg = /^1\d{10}$/
        // let re1 = reg.test("lijiapeng")
        // let re2 = reg.test("2020lijiapeng")
        // let re3 = reg.test("lijiapeng2019")
        // let re4 = reg.test("12312321432")
        // console.log(re1, re2, re3, re4)
        // ----------------------------------
        // let str = "\d"
        // let reg = /^\\d$/ //=>把特殊符号转换为普通符号
        // console.log(reg.test(str))




        // ----------------------------------------------------
        // 习题
        // 1.验证是否为有效数字
        // let reg = /^[+-]?(\d|(1-9)\d+))(\.\d+)?$/
        // 2.验证密码的
        // let val = userPassInp.value
        //函数实现方式
        // function checkoutPass(val) {
        //     if (val.length < 6 || val.length > 16) {
        //         alert("长度介于6-16之间")
        //         return
        //     }
        //     let area = ["a", "b", "_"]
        //     for (let i = 0; i < area.length; i++) {
        //         let char = area[i]
        //         if (!area.includes(char)) {
        //             alert("格式不正确！");
        //             return
        //         }
        //     }
        // }
        //正则方式
        // reg = /^\w{6,16}$/
        // let flag = reg.test(val)
        //3.验证真实姓名
        // let reg = /^[\u4E00-\u9FA5]{2,10}(.[\u4E00-\u9FA5]){2,10}){0,2}$/
        //4.验证邮箱的
        // let reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/
        //5.身份账号吗
        // let reg = /^\d{17}(\d|X)$/
        //通过小括号单独捕获
        let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|x)$/;
        let result = reg.exec("231005199706280531")
        console.log(result)

        //=>正则表达式的一部分是变量存储的值
        // 1.两斜杠中间抱起来的都是元字符
        let type = "lijiapeng"
        reg = /^@"+type+"@$/
        reg.test("@lijiapneg@") //false
        reg.test('@""typppppeee@') //true

        // 构造函数方式创建
        reg = new RegExp("^@" + type + "@$")
        console.log(reg.test("@lijiapeng@"))
    </script> -->



    <!-- <script>
        // 正则捕获
        // 正则捕获的前提是：当前正则要和字符串匹配，如果不匹配捕获的结果是null
        //    1.捕获的结果是null或者一个数组
        //    数组第一项：是当前捕获到的内容
        //    其余项：对应小分组本次单独捕获内容
        //    index：代表当前捕获内容在当前字符串中的索引
        //    input：代表原始字符串

        //懒惰性：2.每执行一次exec只能捕获到一个符合正则规则的，默认情况下执行无数次永远都是第一次捕获到的
        //       lastIndex：是当前正则下一次匹配的起始索引位置，第一次捕获完成，lastIndex没有改变，所以永远找到的都是第一个
        //       解决办法应用全局修饰符g



        let str = "lijiapeng2019lijiapeng2020xiongqi2021";
        // // let reg = /\d+/
        // let reg = /\d+/g //设置全局修饰符 第一次匹配过后lastIndex会自己修改 当全部捕获后再次捕获的结果为null 此时lastIndex回归初始值0
        // console.log(reg.exec(str))
        // console.log(reg.exec(str))

        // if (reg.test(str)) {
        //     console.log(reg.lastIndex); //继续test匹配后，lastIndex已经被修改为第一次匹配后的结果，从而下一次就不从头开始了
        //     console.log(reg.exec(str)) // 结果2020
        // }
        // 所以不要做判断

        //=>编写一个方法execAll执行一次把所有结果匹配到 设置g全局修饰符的规则
        // 字符串 match 方法源码
        // ~ function() {
        //     function execAll(str = "") {
        //         //=>str：要匹配的字符串
        //         //=>this.RegExp的实例（当前操作的正则）
        //         //需要判断正则是否加g 否则条件永远成立，会死循环
        //         if (!this.global) {
        //             return this.exec(str)
        //         }
        //         let arr = [];
        //         let res = this.exec(str)
        //         while (res != null) {
        //             arr.push(res[0])
        //             res = this.exec(str)
        //         }
        //         return arr
        //     }
        //     RegExp.prototype.execAll = execAll
        // }()
        let reg = /\d+/g
            // console.log(reg.execAll(str))
        console.log(str.match(reg))
    </script> -->


    <!-- <script>
        // 正则分组捕获
        let str = "231005199706280531"

        let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(?:\d|X)$/

        console.log(reg.exec(str))
        console.log(str.match(reg))
            //第一项为大正则捕获的结果，其余项为小分组单独捕获的结果


        //分组引用
        let str = "book"
        let reg = /^[a-zA-Z]([a-zA-z])\1[a-zA-Z]$/
    </script> -->

    <!-- <script>
        // 正则捕获的贪婪性:默认情况下正则捕获，是按照当前正则匹配的最长结果来获取的,问号取消贪婪性
        let str = '李佳朋@2019@2020成功'
        let reg = /\d+/g;
        let reg = /\d+?/g;
        console.log(str.match(reg))

        // 问号左边是非量词元字符：本身代表量词元字符，出现零到一次
        // 问号左边是量词元字符：取消捕获的时候的贪婪性
        // （？：）只匹配不捕获
        //（？=） 正向预查
        //（？！）负向预查
    </script> -->

    <script>
        let str = "${0}年${1}月${2}日"
        let reg = /\$\{(\d+)\}/g
        console.log(reg.test(str))
    </script>

</body>

</html>